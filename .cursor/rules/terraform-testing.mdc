---
description: 
globs: 
alwaysApply: false
---
# Terraform Testing Standards

## Unit Testing

### Module Testing
- Test all module inputs
- Test all module outputs
- Test all module resources
- Test all module data sources
- Test module validation rules
- Test module error handling
- Test module edge cases
- Test module performance

### Variable Testing
- Test variable validation
- Test variable defaults
- Test variable types
- Test variable descriptions
- Test variable constraints
- Test variable dependencies
- Test variable error handling
- Test variable edge cases

### Output Testing
- Test output values
- Test output descriptions
- Test output dependencies
- Test output formatting
- Test output validation
- Test output error handling
- Test output edge cases
- Test output performance

## Integration Testing

### Provider Testing
- Test provider configuration
- Test provider authentication
- Test provider resources
- Test provider data sources
- Test provider error handling
- Test provider edge cases
- Test provider performance
- Test provider compatibility

### Resource Testing
- Test resource creation
- Test resource updates
- Test resource deletion
- Test resource dependencies
- Test resource validation
- Test resource error handling
- Test resource edge cases
- Test resource performance

### State Testing
- Test state management
- Test state locking
- Test state backup
- Test state recovery
- Test state validation
- Test state error handling
- Test state edge cases
- Test state performance

## Functional Testing

### Resource Functionality
- Test resource functionality
- Test resource behavior
- Test resource interactions
- Test resource lifecycle
- Test resource validation
- Test resource error handling
- Test resource edge cases
- Test resource performance

### Module Functionality
- Test module functionality
- Test module behavior
- Test module interactions
- Test module lifecycle
- Test module validation
- Test module error handling
- Test module edge cases
- Test module performance

## Performance Testing

### Resource Performance
- Test resource performance
- Test resource scalability
- Test resource reliability
- Test resource efficiency
- Test resource load handling
- Test resource stress testing
- Test resource benchmarking
- Test resource optimization

### Module Performance
- Test module performance
- Test module scalability
- Test module reliability
- Test module efficiency
- Test module load handling
- Test module stress testing
- Test module benchmarking
- Test module optimization

## Security Testing

### Resource Security
- Test resource security
- Test resource access
- Test resource permissions
- Test resource policies
- Test resource encryption
- Test resource authentication
- Test resource authorization
- Test resource compliance

### Module Security
- Test module security
- Test module access
- Test module permissions
- Test module policies
- Test module encryption
- Test module authentication
- Test module authorization
- Test module compliance

## Compliance Testing

### Resource Compliance
- Test resource compliance
- Test resource standards
- Test resource requirements
- Test resource regulations
- Test resource policies
- Test resource procedures
- Test resource documentation
- Test resource auditing

### Module Compliance
- Test module compliance
- Test module standards
- Test module requirements
- Test module regulations
- Test module policies
- Test module procedures
- Test module documentation
- Test module auditing

## Documentation Testing

### Resource Documentation
- Test resource documentation
- Test resource examples
- Test resource descriptions
- Test resource usage
- Test resource validation
- Test resource error handling
- Test resource edge cases
- Test resource performance

### Module Documentation
- Test module documentation
- Test module examples
- Test module descriptions
- Test module usage
- Test module validation
- Test module error handling
- Test module edge cases
- Test module performance

## Test Automation

### CI/CD Integration
- Integrate with CI/CD
- Automate test execution
- Automate test reporting
- Automate test documentation
- Automate test validation
- Automate test error handling
- Automate test edge cases
- Automate test performance

### Test Environment
- Use proper test environment
- Use proper test data
- Use proper test tools
- Use proper test documentation
- Use proper test validation
- Use proper test error handling
- Use proper test edge cases
- Use proper test performance

## Test Tools

### Testing Frameworks
- Use proper testing framework
- Use proper test runner
- Use proper test reporter
- Use proper test validator
- Use proper test analyzer
- Use proper test optimizer
- Use proper test documenter
- Use proper test manager

### Test Utilities
- Use proper test utilities
- Use proper test helpers
- Use proper test fixtures
- Use proper test mocks
- Use proper test stubs
- Use proper test spies
- Use proper test fakes
- Use proper test doubles

## Test Documentation

### Test Plans
- Document test plans
- Document test cases
- Document test scenarios
- Document test data
- Document test environment
- Document test tools
- Document test procedures
- Document test results

### Test Reports
- Generate test reports
- Document test results
- Document test coverage
- Document test performance
- Document test issues
- Document test recommendations
- Document test improvements
- Document test lessons learned

## Terratest Implementation

### Project Structure
```
terraform-module/
├── main.tf
├── variables.tf
├── outputs.tf
├── ...
├── test/
│   ├── go.mod
│   ├── go.sum
│   └── module_test.go
```

### Test File Structure
```go
package test

import (
    "testing"
    "github.com/gruntwork-io/terratest/modules/terraform"
    "github.com/stretchr/testify/assert"
)

func TestTerraformModule(t *testing.T) {
    terraformOptions := &terraform.Options{
        TerraformDir: "../",
        Vars: map[string]interface{}{
            "environment": "test",
            "region":     "us-west-1",
        },
    }

    defer terraform.Destroy(t, terraformOptions)
    terraform.InitAndApply(t, terraformOptions)

    // Add assertions here
}
```

### Terratest Best Practices

#### 1. Test Setup
```go
// Use a consistent setup pattern
func TestModule(t *testing.T) {
    t.Parallel()  // Enable parallel testing

    // Unique names for each test
    uniqueID := random.UniqueId()
    instanceName := fmt.Sprintf("terratest-%s", uniqueID)

    terraformOptions := &terraform.Options{
        TerraformDir: "../",
        Vars: map[string]interface{}{
            "name": instanceName,
        },
        // Retry on known errors
        RetryableTerraformErrors: map[string]string{
            "RequestError":    "Temporary AWS error",
            "ConnectionError": "Network issue",
        },
        MaxRetries:         3,
        TimeBetweenRetries: 5 * time.Second,
    }

    // Clean up resources after test
    defer terraform.Destroy(t, terraformOptions)
    
    // Initialize and apply
    terraform.InitAndApply(t, terraformOptions)
}
```

#### 2. Resource Testing
```go
// Test resource creation and properties
func TestResourceCreation(t *testing.T) {
    // ... setup code ...

    // Test output values
    output := terraform.Output(t, terraformOptions, "instance_id")
    assert.NotEmpty(t, output)

    // Test AWS resource
    instance := aws.GetEC2InstanceById(t, output, awsRegion)
    assert.Equal(t, instance.InstanceType, "t2.micro")
    
    // Test resource tags
    expectedTags := map[string]string{
        "Environment": "test",
        "Terraform":   "true",
    }
    assert.Equal(t, instance.Tags, expectedTags)
}
```

#### 3. Error Handling
```go
// Test error conditions
func TestErrorConditions(t *testing.T) {
    terraformOptions := &terraform.Options{
        TerraformDir: "../",
        Vars: map[string]interface{}{
            "instance_type": "invalid_type",
        },
    }

    // Expect error
    _, err := terraform.InitAndApplyE(t, terraformOptions)
    assert.Error(t, err)
    assert.Contains(t, err.Error(), "Invalid instance type")
}
```

#### 4. HTTP Testing
```go
// Test HTTP endpoints
func TestHTTPEndpoint(t *testing.T) {
    // ... setup code ...

    // Get endpoint URL
    url := terraform.Output(t, terraformOptions, "endpoint_url")

    // Test HTTP response
    http_helper.HttpGetWithRetry(t, url, nil, 200, "Hello, World!", 30, 5*time.Second)
}
```

#### 5. Database Testing
```go
// Test database connections
func TestDatabase(t *testing.T) {
    // ... setup code ...

    // Get database connection info
    dbEndpoint := terraform.Output(t, terraformOptions, "db_endpoint")
    dbPort := terraform.Output(t, terraformOptions, "db_port")
    dbUser := terraform.Output(t, terraformOptions, "db_user")
    dbPassword := terraform.Output(t, terraformOptions, "db_password")

    // Test database connection
    connectionString := fmt.Sprintf(
        "host=%s port=%s user=%s password=%s dbname=postgres sslmode=require",
        dbEndpoint, dbPort, dbUser, dbPassword,
    )
    db, err := sql.Open("postgres", connectionString)
    assert.NoError(t, err)
    defer db.Close()

    err = db.Ping()
    assert.NoError(t, err)
}
```

### Terratest Validation Rules

1. **Test Organization**
   - One test file per module
   - Clear test function names
   - Logical test grouping
   - Proper test isolation
   - Cleanup after tests

2. **Resource Validation**
   - Verify resource creation
   - Check resource properties
   - Validate resource tags
   - Test resource relationships
   - Confirm resource deletion

3. **Error Handling**
   - Test invalid inputs
   - Check error messages
   - Validate retry logic
   - Test timeout handling
   - Verify cleanup on failure

4. **Performance Considerations**
   - Enable parallel testing
   - Use proper timeouts
   - Implement retry logic
   - Monitor test duration
   - Optimize resource usage

### Terratest Patterns

#### 1. Retry Pattern
```go
maxRetries := 3
timeBetweenRetries := 5 * time.Second

retry.DoWithRetry(t, "Checking resource status", maxRetries, timeBetweenRetries,
    func() (string, error) {
        // Check resource status
        status := aws.GetResourceStatus(t, resourceId)
        if status != "ready" {
            return "", fmt.Errorf("Resource not ready")
        }
        return status, nil
    },
)
```

#### 2. Cleanup Pattern
```go
func TestWithCleanup(t *testing.T) {
    // Create test resources
    resources := createTestResources(t)
    
    // Register cleanup function
    t.Cleanup(func() {
        cleanupResources(resources)
    })
    
    // Run tests
    runTests(t, resources)
}
```

#### 3. Assertion Pattern
```go
func TestWithAssertions(t *testing.T) {
    // ... setup code ...

    // Multiple assertions
    assert.NotEmpty(t, output)
    assert.Contains(t, output, expectedValue)
    assert.Regexp(t, regexp.MustCompile(`^prefix-.*-suffix$`), output)
    
    // Custom error messages
    assert.Equal(t, expected, actual, "Values should match: %v != %v", expected, actual)
}
```

### Terratest CI/CD Integration

#### 1. GitHub Actions Example
```yaml
name: Terratest
on: [push, pull_request]

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      
      - name: Set up Go
        uses: actions/setup-go@v2
        with:
          go-version: 1.19
          
      - name: Install Terraform
        uses: hashicorp/setup-terraform@v1
        
      - name: Run Terratest
        run: |
          cd test
          go test -v -timeout 30m
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
```

#### 2. Test Reporting
```go
func TestMain(m *testing.M) {
    // Setup test reporting
    report := testing.MainStart(testReporter{}, "")
    code := m.Run()
    report.End()
    os.Exit(code)
}

type testReporter struct{}

func (tr testReporter) Format(r *testing.Report) {
    // Format and save test results
    results := formatTestResults(r)
    saveTestResults(results)
}
```
