---
description: 
globs: 
alwaysApply: false
---
# Terraform Project Configuration Rules


## File Organization

### Project Structure
```
terraform-project/
├── providers.tf          # Provider configurations
├── backend.tf           # State backend configuration
├── versions.tf          # Version constraints
├── variables.tf         # Input variables
├── outputs.tf          # Output definitions
├── locals.tf           # Local variables
├── terraform.tfvars    # Variable values
├── data.tf             # Data source declarations
│
# Core Infrastructure
├── network.tf         # Network configurations
├── dns.tf            # DNS configurations
├── firewall.tf       # Firewall rules and security
│
# Identity and Access
├── auth.tf           # Authentication configurations
├── roles.tf          # Role definitions
├── policies.tf       # Policy configurations
│
# Compute Resources
├── instances.tf      # Compute instances
├── clusters.tf       # Container/cluster configurations
├── scaling.tf        # Auto-scaling configurations
├── loadbalancer.tf   # Load balancer configurations
│
# Storage Resources
├── object_storage.tf # Object storage (buckets, blobs)
├── databases.tf      # Database instances
├── caching.tf        # Caching services
│
# Monitoring
├── metrics.tf        # Metrics and monitoring
├── logs.tf          # Logging configurations
├── alerts.tf        # Alert configurations
│
# Modules (if needed)
└── modules/         # Only folder for reusable modules
```

### File Content Rules

1. **Base Configuration Files**

#### providers.tf
```hcl
# Provider configurations
terraform {
  required_providers {
    # Example provider configurations
    provider_name = {
      source  = "namespace/provider"
      version = "~> X.Y"
    }
  }
}

provider "provider_name" {
  # Provider-specific configurations
}
```

#### backend.tf
```hcl
terraform {
  backend "type" {
    # Backend-specific configurations
  }
}
```

#### variables.tf
```hcl
# Common Variables
variable "project_name" {
  type        = string
  description = "Project name"
}

variable "environment" {
  type        = string
  description = "Environment name"
}

# Network Variables
variable "network_config" {
  type = object({
    cidr_block = string
    subnets    = map(string)
  })
  description = "Network configuration"
}

# Compute Variables
variable "compute_config" {
  type = map(object({
    size  = string
    count = number
  }))
  description = "Compute configurations"
}
```

2. **Infrastructure Files**

#### network.tf
```hcl
# Network resources
resource "provider_name_network" "main" {
  name       = "${local.prefix}-network"
  cidr_block = var.network_config.cidr_block
  
  tags = local.common_tags
}
```

#### firewall.tf
```hcl
# Firewall rules
resource "provider_name_firewall" "main" {
  name        = "${local.prefix}-firewall"
  description = "Main firewall rules"
  network     = provider_name_network.main.id

  # Rule configurations
}
```

3. **Resource Files**

#### instances.tf
```hcl
# Compute instances
resource "provider_name_instance" "main" {
  name  = "${local.prefix}-instance"
  size  = var.compute_config["main"].size
  count = var.compute_config["main"].count

  network_interface {
    network = provider_name_network.main.id
  }
  
  tags = local.common_tags
}
```

#### databases.tf
```hcl
# Database instances
resource "provider_name_database" "main" {
  name     = "${local.prefix}-db"
  version  = var.database_version
  
  network  = provider_name_network.main.id
  
  tags = local.common_tags
}
```

### File Organization Rules

1. **File Naming Conventions**
   - Use lowercase with underscores
   - Names should indicate resource type
   - Keep names generic and provider-agnostic
   - Use standard `.tf` extension

2. **Resource Grouping**
   - Group by resource function, not provider service names
   - Keep related resources in the same file
   - Use consistent resource naming patterns

3. **File Dependencies**
   - Reference variables from `variables.tf`
   - Use locals from `locals.tf`
   - Define outputs in `outputs.tf`
   - Keep data sources in `data.tf`

4. **Resource Naming Pattern**
```hcl
# Example of consistent resource naming
resource "provider_name_resource" "purpose" {
  name = "${local.prefix}-${var.purpose}"
  # ... other configurations
}
```

5. **Variable Organization**
```hcl
# Group variables by purpose
# Infrastructure
variable "infrastructure_config" { }

# Application
variable "application_config" { }

# Operations
variable "operations_config" { }
```

6. **Output Organization**
```hcl
# Group outputs by resource type
output "network_info" { }
output "compute_info" { }
output "storage_info" { }
```

### Best Practices

1. **File Management**
   - Keep files under 300 lines
   - Split by resource function
   - Use consistent formatting
   - Follow provider-agnostic patterns
2. **Resource Dependencies**
   - Use explicit dependencies
   - Document dependencies
   - Keep related resources together

3. **Documentation**
   - Add descriptive comments
   - Document configurations
   - Include usage examples
   - Keep provider-specific notes separate

4. **State Management**
   - Use remote state storage
   - Implement state locking
   - Regular state backups
   - Plan for state migrations

5. **Tagging Strategy**
```hcl
locals {
  common_tags = {
    Environment = var.environment
    Project     = var.project_name
    ManagedBy   = "terraform"
  }
}
```

6. **Module Usage**
   - Create provider-agnostic modules
   - Use consistent interfaces
   - Document provider requirements
   - Version all modules

## Configuration Standards

### 1. Version Control
```hcl
# versions.tf
terraform {
  required_version = ">= 1.0.0"
  required_providers {
    aws = {
      source  = "hashicorp/aws"
      version = "~> 4.0"
    }
  }
}
```

### 2. Resource Naming Convention
- Format: `<project>-<environment>-<region>-<resource>-<purpose>`
- Example: `myapp-prod-us-east-1-rds-main`
- Use lowercase and hyphens only
- Maximum length: 60 characters

### 3. Tagging Strategy
```hcl
locals {
  mandatory_tags = {
    Environment = var.environment
    Project     = var.project_name
    Owner       = var.team_name
    ManagedBy   = "terraform"
    CostCenter  = var.cost_center
  }
}
```

### 4. State Management
```hcl
# Backend configuration (environments/<env>/main.tf)
terraform {
  backend "s3" {
    bucket         = "<project>-terraform-state"
    key            = "<environment>/terraform.tfstate"
    region         = "us-east-1"
    encrypt        = true
    dynamodb_table = "<project>-terraform-locks"
  }
}
```

### 5. Variable Definition Standards
```hcl
# Required variable format
variable "example_variable" {
  type        = string
  description = "Detailed description of the variable purpose"
  validation {
    condition     = length(var.example_variable) > 0
    error_message = "The variable cannot be empty."
  }
}

# Variable with validation
variable "environment" {
  type        = string
  description = "Environment name"
  validation {
    condition     = contains(["dev", "staging", "prod"], var.environment)
    error_message = "Environment must be dev, staging, or prod."
  }
}
```

## Security Requirements

### 1. Access Control
- Use IAM roles with least privilege
- Enable MFA for state bucket access
- Use separate state files per environment
- Encrypt sensitive data in state files

### 2. Sensitive Data Handling
```hcl
# Mark sensitive variables
variable "database_password" {
  type        = string
  sensitive   = true
  description = "Database password"
}

# Use KMS for encryption
resource "aws_kms_key" "main" {
  description             = "KMS key for encryption"
  deletion_window_in_days = 7
  enable_key_rotation     = true
}
```

### 3. Network Security
- Use private subnets for resources
- Implement security groups with minimal access
- Enable VPC Flow Logs
- Use VPC endpoints where possible

## Module Requirements

### 1. Module Structure
```hcl
# modules/<module_name>/
# - README.md         # Documentation
# - main.tf          # Main resources
# - variables.tf     # Input variables
# - outputs.tf       # Output values
# - versions.tf      # Version constraints
```

### 2. Module Documentation
```markdown
# Module: <module_name>

## Description
Brief description of module purpose

## Requirements
- Minimum Terraform version
- Required providers
- Required permissions

## Inputs
| Name | Description | Type | Default | Required |
|------|-------------|------|---------|:--------:|
| name | Resource name | string | n/a | yes |

## Outputs
| Name | Description |
|------|-------------|
| id | Resource ID |

## Example Usage
```hcl
module "example" {
  source = "./modules/example"
  name   = "example-resource"
}
```
```

## Environment-Specific Requirements

### 1. Development Environment
- Lower resource specifications
- Debug logging enabled
- Relaxed backup policies
- Cost optimization features enabled

### 2. Staging Environment
- Production-like configuration
- Test data only
- Monitoring enabled
- Automated cleanup policies

### 3. Production Environment
- High availability configuration
- Strict security policies
- Full backup and DR policies
- Performance optimization

## Monitoring and Logging

### 1. Required Monitoring
- Enable CloudWatch metrics
- Set up log aggregation
- Configure alerting thresholds
- Enable audit logging

### 2. Required Tags for Monitoring
```hcl
locals {
  monitoring_tags = {
    MonitoringLevel = var.monitoring_level
    AlertContacts   = var.alert_contacts
    BackupPolicy    = var.backup_policy
  }
}
```

## Compliance and Governance

### 1. Required Compliance Tags
```hcl
locals {
  compliance_tags = {
    DataClassification = var.data_classification
    ComplianceLevel   = var.compliance_level
    RetentionPeriod   = var.retention_period
  }
}
```

### 2. Audit Requirements
- Enable AWS CloudTrail
- Configure AWS Config
- Set up compliance reports
- Implement regular audits 

## Variable Validation Rules

### 1. Basic Variable Validation

```hcl
# String validation
variable "environment" {
  type        = string
  description = "Environment name"
  
  validation {
    condition     = contains(["dev", "staging", "prod"], var.environment)
    error_message = "Environment must be one of: dev, staging, prod."
  }
}

# Number validation
variable "instance_count" {
  type        = number
  description = "Number of instances to create"
  
  validation {
    condition     = var.instance_count > 0 && var.instance_count <= 10
    error_message = "Instance count must be between 1 and 10."
  }
}

# List validation
variable "allowed_ports" {
  type        = list(number)
  description = "List of allowed ports"
  
  validation {
    condition     = alltrue([for port in var.allowed_ports : port >= 1 && port <= 65535])
    error_message = "All ports must be between 1 and 65535."
  }
}

# Map validation
variable "resource_tags" {
  type        = map(string)
  description = "Resource tags"
  
  validation {
    condition     = length(var.resource_tags) > 0
    error_message = "At least one tag must be specified."
  }
  
  validation {
    condition     = can(var.resource_tags["environment"])
    error_message = "The 'environment' tag must be specified."
  }
}
```

### 2. Complex Type Validation

```hcl
# Object validation
variable "network_config" {
  type = object({
    cidr_block = string
    subnets    = map(string)
    dns_servers = list(string)
    enable_ipv6 = bool
  })
  description = "Network configuration"
  
  validation {
    condition     = can(regex("^\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}/\\d{1,2}$", var.network_config.cidr_block))
    error_message = "CIDR block must be in valid IPv4 CIDR notation (e.g., 10.0.0.0/16)."
  }
  
  validation {
    condition     = length(var.network_config.subnets) > 0
    error_message = "At least one subnet must be defined."
  }
  
  validation {
    condition     = alltrue([for ip in var.network_config.dns_servers : can(regex("^\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}$", ip))])
    error_message = "All DNS servers must be valid IPv4 addresses."
  }
}

# Nested object validation
variable "database_config" {
  type = object({
    instance = object({
      size     = string
      version  = string
      replicas = number
    })
    backup = object({
      enabled     = bool
      retention_days = number
    })
  })
  description = "Database configuration"
  
  validation {
    condition     = contains(["small", "medium", "large"], var.database_config.instance.size)
    error_message = "Instance size must be one of: small, medium, large."
  }
  
  validation {
    condition     = can(regex("^\\d+\\.\\d+\\.\\d+$", var.database_config.instance.version))
    error_message = "Version must be in format X.Y.Z (e.g., 13.2.0)."
  }
  
  validation {
    condition     = var.database_config.instance.replicas >= 0 && var.database_config.instance.replicas <= 5
    error_message = "Number of replicas must be between 0 and 5."
  }
  
  validation {
    condition     = !var.database_config.backup.enabled || var.database_config.backup.retention_days >= 7
    error_message = "If backups are enabled, retention must be at least 7 days."
  }
}
```

### 3. Custom Validation Functions

```hcl
# Local validation functions
locals {
  validate_port = function(port) {
    port >= 1 && port <= 65535
  }
  
  validate_ip = function(ip) {
    can(regex("^\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}$", ip))
  }
  
  validate_cidr = function(cidr) {
    can(regex("^\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}/\\d{1,2}$", cidr))
  }
}

# Using custom validation functions
variable "service_config" {
  type = object({
    port     = number
    ip       = string
    networks = list(string)
  })
  description = "Service configuration"
  
  validation {
    condition     = local.validate_port(var.service_config.port)
    error_message = "Invalid port number."
  }
  
  validation {
    condition     = local.validate_ip(var.service_config.ip)
    error_message = "Invalid IP address."
  }
  
  validation {
    condition     = alltrue([for net in var.service_config.networks : local.validate_cidr(net)])
    error_message = "Invalid network CIDR."
  }
}
```

### 4. Conditional Validation

```hcl
# Interdependent variable validation
variable "storage_config" {
  type = object({
    type       = string
    size_gb    = number
    encrypted  = bool
    kms_key_id = string
  })
  description = "Storage configuration"
  
  validation {
    condition     = contains(["ssd", "hdd", "premium-ssd"], var.storage_config.type)
    error_message = "Storage type must be one of: ssd, hdd, premium-ssd."
  }
  
  validation {
    condition     = var.storage_config.size_gb >= 10
    error_message = "Storage size must be at least 10 GB."
  }
  
  validation {
    condition     = !var.storage_config.encrypted || var.storage_config.kms_key_id != ""
    error_message = "KMS key ID is required when encryption is enabled."
  }
}

# Environment-specific validation
variable "resource_config" {
  type = object({
    environment = string
    size       = string
    replicas   = number
    backup     = bool
  })
  description = "Resource configuration"
  
  validation {
    condition     = var.resource_config.environment == "prod" ? var.resource_config.replicas >= 2 : true
    error_message = "Production environment requires at least 2 replicas."
  }
  
  validation {
    condition     = var.resource_config.environment == "prod" ? var.resource_config.backup : true
    error_message = "Backup must be enabled in production environment."
  }
  
  validation {
    condition     = var.resource_config.environment == "prod" ? var.resource_config.size == "large" : true
    error_message = "Production environment requires 'large' size."
  }
}
```

### 5. Best Practices for Variable Validation

1. **Validation Complexity**
   - Start with simple validations
   - Add complex validations as needed
   - Use custom functions for reusable validation logic
   - Document validation rules in variable descriptions

2. **Error Messages**
   - Be specific about the error
   - Include valid values in the message
   - Explain the validation rule
   - Reference documentation if needed

3. **Validation Types**
   - Format validation (regex)
   - Range validation (min/max)
   - Enumeration validation (allowed values)
   - Dependency validation (conditional)
   - Cross-field validation

4. **Performance Considerations**
   - Keep validations simple
   - Avoid complex computations
   - Cache repeated validations in locals
   - Use built-in functions when possible 
