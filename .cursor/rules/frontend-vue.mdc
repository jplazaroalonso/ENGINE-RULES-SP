---
description:
globs:
alwaysApply: false
---
# Frontend Applications with Vue.js - Context Document

## 1. Architecture Overview

### 1.1 Vue.js Application Architecture
- **Presentation Layer**
  - Vue 3 components with Composition API
  - TypeScript for type safety
  - Single File Components (SFC)

- **State Management Layer**
  - Pinia for global state management
  - Local state with reactive refs
  - Composables for reusable logic

- **Communication Layer**
  - gRPC-Web for API communication
  - HTTP clients for REST APIs
  - WebSocket for real-time features

- **Routing Layer**
  - Vue Router for navigation
  - Route guards for authentication
  - Lazy loading for code splitting

### 1.2 Technology Stack
- **Frontend Framework**
  - Vue.js 3 with Composition API
  - TypeScript for type safety
  - Vite for build tooling
  - Vitest for testing

- **UI Framework**
  - Vuetify 3 or Tailwind CSS
  - Component library (Headless UI, Quasar)
  - Icons (Heroicons, Material Icons)

- **State Management**
  - Pinia for global state
  - VueUse for composables
  - Reactive utilities

## 2. Component Architecture

### 2.1 Composition API Structure
```vue
<template>
  <div class="user-profile">
    <UserHeader :user="user" @edit="handleEdit" />
    <UserDetails 
      :user="user" 
      :loading="loading"
      @update="handleUpdate"
    />
    <UserActions 
      :can-edit="canEdit"
      @delete="handleDelete"
    />
  </div>
</template>

<script setup lang="ts">
import { computed, onMounted, ref } from 'vue'
import { useUserStore } from '@/stores/user'
import { useAuthStore } from '@/stores/auth'
import type { User } from '@/types/user'

// Props
interface Props {
  userId: string
  readonly?: boolean
}

const props = withDefaults(defineProps<Props>(), {
  readonly: false
})

// Emits
interface Emits {
  (e: 'userUpdated', user: User): void
  (e: 'userDeleted', userId: string): void
}

const emit = defineEmits<Emits>()

// Stores
const userStore = useUserStore()
const authStore = useAuthStore()

// Reactive state
const loading = ref(false)
const user = ref<User | null>(null)

// Computed properties
const canEdit = computed(() => 
  !props.readonly && 
  authStore.hasPermission('users:edit') &&
  authStore.user?.id === props.userId
)

// Methods
const loadUser = async () => {
  loading.value = true
  try {
    user.value = await userStore.fetchUser(props.userId)
  } catch (error) {
    console.error('Failed to load user:', error)
  } finally {
    loading.value = false
  }
}

const handleEdit = () => {
  if (canEdit.value && user.value) {
    // Navigate to edit page or open modal
  }
}

const handleUpdate = async (updatedUser: User) => {
  try {
    await userStore.updateUser(updatedUser)
    user.value = updatedUser
    emit('userUpdated', updatedUser)
  } catch (error) {
    console.error('Failed to update user:', error)
  }
}

const handleDelete = async () => {
  if (user.value && confirm('Are you sure?')) {
    try {
      await userStore.deleteUser(user.value.id)
      emit('userDeleted', user.value.id)
    } catch (error) {
      console.error('Failed to delete user:', error)
    }
  }
}

// Lifecycle
onMounted(() => {
  loadUser()
})
</script>

<style scoped>
.user-profile {
  @apply max-w-4xl mx-auto p-6 space-y-6;
}
</style>
```

### 2.2 Composables Pattern
```typescript
// composables/useApi.ts
import { ref, type Ref } from 'vue'

export interface UseApiOptions {
  immediate?: boolean
  onError?: (error: Error) => void
}

export function useApi<T>(
  apiCall: () => Promise<T>,
  options: UseApiOptions = {}
) {
  const data: Ref<T | null> = ref(null)
  const loading = ref(false)
  const error = ref<Error | null>(null)

  const execute = async () => {
    loading.value = true
    error.value = null

    try {
      data.value = await apiCall()
    } catch (err) {
      error.value = err instanceof Error ? err : new Error(String(err))
      if (options.onError) {
        options.onError(error.value)
      }
    } finally {
      loading.value = false
    }
  }

  if (options.immediate) {
    execute()
  }

  return {
    data: readonly(data),
    loading: readonly(loading),
    error: readonly(error),
    execute,
    refresh: execute
  }
}

// composables/useForm.ts
import { reactive, computed } from 'vue'

export interface ValidationRule {
  (value: any): boolean | string
}

export interface FormField {
  value: any
  rules: ValidationRule[]
  error?: string
}

export function useForm<T extends Record<string, any>>(
  initialData: T,
  validationRules: Partial<Record<keyof T, ValidationRule[]>> = {}
) {
  const formData = reactive<T>({ ...initialData })
  const errors = reactive<Partial<Record<keyof T, string>>>({})

  const validate = (field?: keyof T) => {
    const fieldsToValidate = field ? [field] : Object.keys(validationRules) as (keyof T)[]
    
    let isValid = true
    
    for (const fieldName of fieldsToValidate) {
      const rules = validationRules[fieldName]
      if (!rules) continue
      
      const value = formData[fieldName]
      let fieldError = ''
      
      for (const rule of rules) {
        const result = rule(value)
        if (result !== true) {
          fieldError = typeof result === 'string' ? result : 'Invalid value'
          isValid = false
          break
        }
      }
      
      errors[fieldName] = fieldError
    }
    
    return isValid
  }

  const reset = () => {
    Object.assign(formData, initialData)
    Object.keys(errors).forEach(key => {
      delete errors[key as keyof T]
    })
  }

  const isValid = computed(() => {
    return Object.values(errors).every(error => !error)
  })

  return {
    formData,
    errors: readonly(errors),
    isValid: readonly(isValid),
    validate,
    reset
  }
}
```

## 3. State Management with Pinia

### 3.1 Store Structure
```typescript
// stores/user.ts
import { defineStore } from 'pinia'
import { ref, computed } from 'vue'
import type { User, CreateUserRequest, UpdateUserRequest } from '@/types/user'
import { userService } from '@/services/userService'

export const useUserStore = defineStore('user', () => {
  // State
  const users = ref<User[]>([])
  const currentUser = ref<User | null>(null)
  const loading = ref(false)
  const error = ref<string | null>(null)

  // Getters
  const getUserById = computed(() => {
    return (id: string) => users.value.find(user => user.id === id)
  })

  const activeUsers = computed(() => {
    return users.value.filter(user => user.status === 'active')
  })

  const totalUsers = computed(() => users.value.length)

  // Actions
  const fetchUsers = async () => {
    loading.value = true
    error.value = null

    try {
      const response = await userService.getUsers()
      users.value = response.data
    } catch (err) {
      error.value = err instanceof Error ? err.message : 'Failed to fetch users'
      throw err
    } finally {
      loading.value = false
    }
  }

  const fetchUser = async (id: string): Promise<User> => {
    // Check if user is already in store
    const existingUser = getUserById.value(id)
    if (existingUser) {
      return existingUser
    }

    loading.value = true
    error.value = null

    try {
      const user = await userService.getUser(id)
      
      // Add to users array if not exists
      const index = users.value.findIndex(u => u.id === id)
      if (index === -1) {
        users.value.push(user)
      } else {
        users.value[index] = user
      }
      
      return user
    } catch (err) {
      error.value = err instanceof Error ? err.message : 'Failed to fetch user'
      throw err
    } finally {
      loading.value = false
    }
  }

  const createUser = async (userData: CreateUserRequest): Promise<User> => {
    loading.value = true
    error.value = null

    try {
      const user = await userService.createUser(userData)
      users.value.push(user)
      return user
    } catch (err) {
      error.value = err instanceof Error ? err.message : 'Failed to create user'
      throw err
    } finally {
      loading.value = false
    }
  }

  const updateUser = async (id: string, userData: UpdateUserRequest): Promise<User> => {
    loading.value = true
    error.value = null

    try {
      const updatedUser = await userService.updateUser(id, userData)
      
      const index = users.value.findIndex(user => user.id === id)
      if (index !== -1) {
        users.value[index] = updatedUser
      }
      
      if (currentUser.value?.id === id) {
        currentUser.value = updatedUser
      }
      
      return updatedUser
    } catch (err) {
      error.value = err instanceof Error ? err.message : 'Failed to update user'
      throw err
    } finally {
      loading.value = false
    }
  }

  const deleteUser = async (id: string): Promise<void> => {
    loading.value = true
    error.value = null

    try {
      await userService.deleteUser(id)
      
      const index = users.value.findIndex(user => user.id === id)
      if (index !== -1) {
        users.value.splice(index, 1)
      }
      
      if (currentUser.value?.id === id) {
        currentUser.value = null
      }
    } catch (err) {
      error.value = err instanceof Error ? err.message : 'Failed to delete user'
      throw err
    } finally {
      loading.value = false
    }
  }

  const setCurrentUser = (user: User | null) => {
    currentUser.value = user
  }

  const clearError = () => {
    error.value = null
  }

  const reset = () => {
    users.value = []
    currentUser.value = null
    loading.value = false
    error.value = null
  }

  return {
    // State
    users: readonly(users),
    currentUser: readonly(currentUser),
    loading: readonly(loading),
    error: readonly(error),
    
    // Getters
    getUserById,
    activeUsers,
    totalUsers,
    
    // Actions
    fetchUsers,
    fetchUser,
    createUser,
    updateUser,
    deleteUser,
    setCurrentUser,
    clearError,
    reset
  }
})
```

### 3.2 Authentication Store
```typescript
// stores/auth.ts
import { defineStore } from 'pinia'
import { ref, computed } from 'vue'
import { router } from '@/router'
import type { User, LoginCredentials } from '@/types/auth'
import { authService } from '@/services/authService'

export const useAuthStore = defineStore('auth', () => {
  // State
  const user = ref<User | null>(null)
  const token = ref<string | null>(localStorage.getItem('auth_token'))
  const loading = ref(false)
  const permissions = ref<string[]>([])

  // Getters
  const isAuthenticated = computed(() => !!token.value && !!user.value)
  
  const hasRole = computed(() => {
    return (role: string) => user.value?.roles?.includes(role) ?? false
  })
  
  const hasPermission = computed(() => {
    return (permission: string) => permissions.value.includes(permission)
  })

  // Actions
  const login = async (credentials: LoginCredentials) => {
    loading.value = true

    try {
      const response = await authService.login(credentials)
      
      token.value = response.token
      user.value = response.user
      permissions.value = response.permissions
      
      localStorage.setItem('auth_token', response.token)
      
      // Redirect to intended page or dashboard
      const redirectTo = router.currentRoute.value.query.redirect as string
      await router.push(redirectTo || '/dashboard')
    } catch (error) {
      throw error
    } finally {
      loading.value = false
    }
  }

  const logout = async () => {
    try {
      if (token.value) {
        await authService.logout()
      }
    } catch (error) {
      console.error('Logout error:', error)
    } finally {
      token.value = null
      user.value = null
      permissions.value = []
      
      localStorage.removeItem('auth_token')
      await router.push('/login')
    }
  }

  const refreshToken = async () => {
    if (!token.value) return false

    try {
      const response = await authService.refreshToken()
      token.value = response.token
      localStorage.setItem('auth_token', response.token)
      return true
    } catch (error) {
      await logout()
      return false
    }
  }

  const fetchProfile = async () => {
    if (!token.value) return

    try {
      const profile = await authService.getProfile()
      user.value = profile.user
      permissions.value = profile.permissions
    } catch (error) {
      console.error('Failed to fetch profile:', error)
      await logout()
    }
  }

  const updateProfile = async (profileData: Partial<User>) => {
    if (!user.value) return

    try {
      const updatedUser = await authService.updateProfile(profileData)
      user.value = { ...user.value, ...updatedUser }
    } catch (error) {
      throw error
    }
  }

  return {
    // State
    user: readonly(user),
    token: readonly(token),
    loading: readonly(loading),
    permissions: readonly(permissions),
    
    // Getters
    isAuthenticated,
    hasRole,
    hasPermission,
    
    // Actions
    login,
    logout,
    refreshToken,
    fetchProfile,
    updateProfile
  }
}, {
  persist: {
    key: 'auth',
    storage: localStorage,
    paths: ['user', 'permissions']
  }
})
```

## 4. Service Layer

### 4.1 API Service Structure
```typescript
// services/apiClient.ts
import axios, { type AxiosInstance, type AxiosRequestConfig } from 'axios'
import { useAuthStore } from '@/stores/auth'

class ApiClient {
  private client: AxiosInstance

  constructor(baseURL: string) {
    this.client = axios.create({
      baseURL,
      timeout: 10000,
      headers: {
        'Content-Type': 'application/json'
      }
    })

    this.setupInterceptors()
  }

  private setupInterceptors() {
    // Request interceptor
    this.client.interceptors.request.use(
      (config) => {
        const authStore = useAuthStore()
        if (authStore.token) {
          config.headers.Authorization = `Bearer ${authStore.token}`
        }
        return config
      },
      (error) => Promise.reject(error)
    )

    // Response interceptor
    this.client.interceptors.response.use(
      (response) => response,
      async (error) => {
        const authStore = useAuthStore()
        
        if (error.response?.status === 401) {
          const refreshed = await authStore.refreshToken()
          if (refreshed && error.config) {
            return this.client.request(error.config)
          }
          await authStore.logout()
        }
        
        return Promise.reject(error)
      }
    )
  }

  async get<T>(url: string, config?: AxiosRequestConfig): Promise<T> {
    const response = await this.client.get<T>(url, config)
    return response.data
  }

  async post<T>(url: string, data?: any, config?: AxiosRequestConfig): Promise<T> {
    const response = await this.client.post<T>(url, data, config)
    return response.data
  }

  async put<T>(url: string, data?: any, config?: AxiosRequestConfig): Promise<T> {
    const response = await this.client.put<T>(url, data, config)
    return response.data
  }

  async delete<T>(url: string, config?: AxiosRequestConfig): Promise<T> {
    const response = await this.client.delete<T>(url, config)
    return response.data
  }
}

export const apiClient = new ApiClient(import.meta.env.VITE_API_URL)
```

### 4.2 gRPC Service Integration
```typescript
// services/grpcClient.ts
import { GrpcWebFetchTransport } from '@protobuf-ts/grpcweb-transport'
import { UserServiceClient } from '@/proto/user.client'
import type { User, CreateUserRequest } from '@/proto/user'

class GrpcUserService {
  private client: UserServiceClient
  private transport: GrpcWebFetchTransport

  constructor() {
    this.transport = new GrpcWebFetchTransport({
      baseUrl: import.meta.env.VITE_GRPC_URL,
      fetchInit: {
        credentials: 'include'
      }
    })
    
    this.client = new UserServiceClient(this.transport)
  }

  async getUsers(): Promise<User[]> {
    const response = await this.client.listUsers({})
    return response.response.users
  }

  async getUser(id: string): Promise<User> {
    const response = await this.client.getUser({ id })
    return response.response.user!
  }

  async createUser(data: CreateUserRequest): Promise<User> {
    const response = await this.client.createUser(data)
    return response.response.user!
  }

  async updateUser(id: string, data: Partial<User>): Promise<User> {
    const response = await this.client.updateUser({
      id,
      ...data
    })
    return response.response.user!
  }

  async deleteUser(id: string): Promise<void> {
    await this.client.deleteUser({ id })
  }

  // Streaming example
  streamUsers(callback: (user: User) => void): () => void {
    const stream = this.client.streamUsers({})
    
    stream.responses.onMessage((user) => {
      callback(user)
    })
    
    stream.responses.onError((error) => {
      console.error('Stream error:', error)
    })
    
    stream.responses.onComplete(() => {
      console.log('Stream completed')
    })
    
    return () => stream.requests.complete()
  }
}

export const grpcUserService = new GrpcUserService()
```

## 5. Routing and Navigation

### 5.1 Router Configuration
```typescript
// router/index.ts
import { createRouter, createWebHistory, type RouteRecordRaw } from 'vue-router'
import { useAuthStore } from '@/stores/auth'

const routes: RouteRecordRaw[] = [
  {
    path: '/',
    redirect: '/dashboard'
  },
  {
    path: '/login',
    name: 'Login',
    component: () => import('@/views/auth/LoginView.vue'),
    meta: { requiresGuest: true }
  },
  {
    path: '/dashboard',
    name: 'Dashboard',
    component: () => import('@/views/DashboardView.vue'),
    meta: { requiresAuth: true }
  },
  {
    path: '/users',
    name: 'Users',
    component: () => import('@/views/users/UsersLayout.vue'),
    meta: { 
      requiresAuth: true,
      permissions: ['users:read']
    },
    children: [
      {
        path: '',
        name: 'UsersList',
        component: () => import('@/views/users/UsersListView.vue')
      },
      {
        path: 'create',
        name: 'CreateUser',
        component: () => import('@/views/users/CreateUserView.vue'),
        meta: { permissions: ['users:create'] }
      },
      {
        path: ':id',
        name: 'UserDetail',
        component: () => import('@/views/users/UserDetailView.vue'),
        props: true
      },
      {
        path: ':id/edit',
        name: 'EditUser',
        component: () => import('@/views/users/EditUserView.vue'),
        props: true,
        meta: { permissions: ['users:edit'] }
      }
    ]
  },
  {
    path: '/:pathMatch(.*)*',
    name: 'NotFound',
    component: () => import('@/views/NotFoundView.vue')
  }
]

export const router = createRouter({
  history: createWebHistory(),
  routes,
  scrollBehavior(to, from, savedPosition) {
    if (savedPosition) {
      return savedPosition
    }
    return { top: 0 }
  }
})

// Route guards
router.beforeEach(async (to, from, next) => {
  const authStore = useAuthStore()
  
  // Check if route requires authentication
  if (to.meta.requiresAuth && !authStore.isAuthenticated) {
    next({ name: 'Login', query: { redirect: to.fullPath } })
    return
  }
  
  // Check if route requires guest (unauthenticated)
  if (to.meta.requiresGuest && authStore.isAuthenticated) {
    next({ name: 'Dashboard' })
    return
  }
  
  // Check permissions
  if (to.meta.permissions && Array.isArray(to.meta.permissions)) {
    const hasPermission = to.meta.permissions.every((permission: string) =>
      authStore.hasPermission(permission)
    )
    
    if (!hasPermission) {
      next({ name: 'Dashboard' }) // or error page
      return
    }
  }
  
  next()
})
```

### 5.2 Navigation Components
```vue
<!-- components/layout/NavigationMenu.vue -->
<template>
  <nav class="navigation-menu">
    <div class="nav-brand">
      <router-link to="/" class="brand-link">
        <img src="/logo.svg" alt="Logo" class="logo" />
        <span class="brand-text">App Name</span>
      </router-link>
    </div>
    
    <ul class="nav-items">
      <li v-for="item in visibleNavItems" :key="item.name">
        <router-link
          :to="item.to"
          class="nav-link"
          :class="{ 'active': isActive(item.to) }"
        >
          <component :is="item.icon" class="nav-icon" />
          <span>{{ item.label }}</span>
        </router-link>
        
        <!-- Submenu -->
        <ul v-if="item.children" class="submenu">
          <li v-for="child in item.children" :key="child.name">
            <router-link :to="child.to" class="submenu-link">
              {{ child.label }}
            </router-link>
          </li>
        </ul>
      </li>
    </ul>
    
    <div class="nav-footer">
      <UserDropdown />
    </div>
  </nav>
</template>

<script setup lang="ts">
import { computed } from 'vue'
import { useRoute } from 'vue-router'
import { useAuthStore } from '@/stores/auth'
import { 
  HomeIcon, 
  UsersIcon, 
  SettingsIcon,
  ChartBarIcon 
} from '@heroicons/vue/24/outline'

const route = useRoute()
const authStore = useAuthStore()

const navigationItems = [
  {
    name: 'dashboard',
    label: 'Dashboard',
    to: '/dashboard',
    icon: HomeIcon,
    permissions: []
  },
  {
    name: 'users',
    label: 'Users',
    to: '/users',
    icon: UsersIcon,
    permissions: ['users:read'],
    children: [
      {
        name: 'users-list',
        label: 'All Users',
        to: '/users',
        permissions: ['users:read']
      },
      {
        name: 'users-create',
        label: 'Create User',
        to: '/users/create',
        permissions: ['users:create']
      }
    ]
  },
  {
    name: 'analytics',
    label: 'Analytics',
    to: '/analytics',
    icon: ChartBarIcon,
    permissions: ['analytics:read']
  },
  {
    name: 'settings',
    label: 'Settings',
    to: '/settings',
    icon: SettingsIcon,
    permissions: ['settings:read']
  }
]

const visibleNavItems = computed(() => {
  return navigationItems.filter(item => {
    if (item.permissions.length === 0) return true
    return item.permissions.every(permission => 
      authStore.hasPermission(permission)
    )
  })
})

const isActive = (to: string) => {
  return route.path.startsWith(to)
}
</script>
```

## 6. Component Patterns

### 6.1 Form Components
```vue
<!-- components/forms/BaseForm.vue -->
<template>
  <form @submit.prevent="handleSubmit" class="base-form">
    <div class="form-fields">
      <slot :form-data="formData" :errors="errors" :loading="loading" />
    </div>
    
    <div class="form-actions">
      <slot name="actions" :loading="loading" :is-valid="isValid">
        <button
          type="button"
          @click="handleReset"
          :disabled="loading"
          class="btn btn-secondary"
        >
          Reset
        </button>
        <button
          type="submit"
          :disabled="!isValid || loading"
          class="btn btn-primary"
        >
          <Spinner v-if="loading" class="btn-spinner" />
          {{ submitText }}
        </button>
      </slot>
    </div>
  </form>
</template>

<script setup lang="ts" generic="T extends Record<string, any>">
import { computed } from 'vue'
import { useForm, type ValidationRule } from '@/composables/useForm'

interface Props {
  initialData: T
  validationRules?: Partial<Record<keyof T, ValidationRule[]>>
  submitText?: string
}

interface Emits {
  (e: 'submit', data: T): void | Promise<void>
  (e: 'reset'): void
}

const props = withDefaults(defineProps<Props>(), {
  submitText: 'Submit'
})

const emit = defineEmits<Emits>()

const { formData, errors, isValid, validate, reset } = useForm(
  props.initialData,
  props.validationRules
)

const loading = ref(false)

const handleSubmit = async () => {
  if (!validate()) return
  
  loading.value = true
  try {
    await emit('submit', formData)
  } finally {
    loading.value = false
  }
}

const handleReset = () => {
  reset()
  emit('reset')
}

defineExpose({
  formData,
  errors,
  isValid,
  validate,
  reset
})
</script>
```

### 6.2 Data Table Component
```vue
<!-- components/data/DataTable.vue -->
<template>
  <div class="data-table">
    <div class="table-header">
      <div class="table-title">
        <h3>{{ title }}</h3>
        <span class="item-count">{{ totalItems }} items</span>
      </div>
      
      <div class="table-actions">
        <SearchInput v-model="searchQuery" placeholder="Search..." />
        <slot name="actions" />
      </div>
    </div>
    
    <div class="table-filters" v-if="$slots.filters">
      <slot name="filters" :filters="filters" @update:filters="updateFilters" />
    </div>
    
    <div class="table-container">
      <table class="table">
        <thead>
          <tr>
            <th
              v-for="column in columns"
              :key="column.key"
              @click="handleSort(column)"
              :class="{ 
                'sortable': column.sortable,
                'sorted': sortField === column.key 
              }"
            >
              {{ column.label }}
              <SortIcon
                v-if="column.sortable"
                :direction="sortField === column.key ? sortDirection : null"
              />
            </th>
            <th v-if="$slots.actions" class="actions-column">Actions</th>
          </tr>
        </thead>
        
        <tbody>
          <tr v-if="loading" class="loading-row">
            <td :colspan="columns.length + ($slots.actions ? 1 : 0)">
              <div class="loading-container">
                <Spinner />
                <span>Loading...</span>
              </div>
            </td>
          </tr>
          
          <tr
            v-else
            v-for="item in paginatedItems"
            :key="getItemKey(item)"
            @click="handleRowClick(item)"
            :class="{ 'clickable': !!$listeners.rowClick }"
          >
            <td v-for="column in columns" :key="column.key">
              <slot
                :name="`cell-${column.key}`"
                :item="item"
                :value="getColumnValue(item, column.key)"
              >
                {{ formatValue(getColumnValue(item, column.key), column) }}
              </slot>
            </td>
            
            <td v-if="$slots.actions" class="actions-cell">
              <slot name="actions" :item="item" />
            </td>
          </tr>
          
          <tr v-if="!loading && paginatedItems.length === 0" class="empty-row">
            <td :colspan="columns.length + ($slots.actions ? 1 : 0)">
              <div class="empty-state">
                <slot name="empty">
                  <p>No items found</p>
                </slot>
              </div>
            </td>
          </tr>
        </tbody>
      </table>
    </div>
    
    <TablePagination
      v-if="totalPages > 1"
      v-model:page="currentPage"
      v-model:page-size="pageSize"
      :total-items="totalItems"
      :total-pages="totalPages"
    />
  </div>
</template>

<script setup lang="ts" generic="T extends Record<string, any>">
import { computed, ref, watch } from 'vue'

interface TableColumn {
  key: string
  label: string
  sortable?: boolean
  formatter?: (value: any) => string
  width?: string
}

interface Props {
  title?: string
  items: T[]
  columns: TableColumn[]
  loading?: boolean
  searchable?: boolean
  sortable?: boolean
  paginated?: boolean
  pageSize?: number
  itemKey?: keyof T | ((item: T) => string)
}

interface Emits {
  (e: 'rowClick', item: T): void
  (e: 'sort', field: string, direction: 'asc' | 'desc'): void
  (e: 'search', query: string): void
  (e: 'filter', filters: Record<string, any>): void
}

const props = withDefaults(defineProps<Props>(), {
  loading: false,
  searchable: true,
  sortable: true,
  paginated: true,
  pageSize: 20,
  itemKey: 'id'
})

const emit = defineEmits<Emits>()

// Reactive state
const searchQuery = ref('')
const sortField = ref<string>('')
const sortDirection = ref<'asc' | 'desc'>('asc')
const currentPage = ref(1)
const filters = ref<Record<string, any>>({})

// Computed properties
const filteredItems = computed(() => {
  let filtered = [...props.items]
  
  // Apply search filter
  if (searchQuery.value) {
    const query = searchQuery.value.toLowerCase()
    filtered = filtered.filter(item =>
      props.columns.some(column =>
        String(getColumnValue(item, column.key))
          .toLowerCase()
          .includes(query)
      )
    )
  }
  
  // Apply custom filters
  Object.entries(filters.value).forEach(([key, value]) => {
    if (value !== null && value !== undefined && value !== '') {
      filtered = filtered.filter(item => {
        const itemValue = getColumnValue(item, key)
        return Array.isArray(value)
          ? value.includes(itemValue)
          : itemValue === value
      })
    }
  })
  
  return filtered
})

const sortedItems = computed(() => {
  if (!sortField.value) return filteredItems.value
  
  return [...filteredItems.value].sort((a, b) => {
    const aValue = getColumnValue(a, sortField.value)
    const bValue = getColumnValue(b, sortField.value)
    
    const comparison = aValue < bValue ? -1 : aValue > bValue ? 1 : 0
    return sortDirection.value === 'desc' ? -comparison : comparison
  })
})

const totalItems = computed(() => filteredItems.value.length)
const totalPages = computed(() => Math.ceil(totalItems.value / props.pageSize))

const paginatedItems = computed(() => {
  if (!props.paginated) return sortedItems.value
  
  const start = (currentPage.value - 1) * props.pageSize
  const end = start + props.pageSize
  return sortedItems.value.slice(start, end)
})

// Methods
const getItemKey = (item: T): string => {
  return typeof props.itemKey === 'function'
    ? props.itemKey(item)
    : String(item[props.itemKey])
}

const getColumnValue = (item: T, key: string): any => {
  return key.includes('.') 
    ? key.split('.').reduce((obj, k) => obj?.[k], item)
    : item[key]
}

const formatValue = (value: any, column: TableColumn): string => {
  if (column.formatter) {
    return column.formatter(value)
  }
  
  if (value === null || value === undefined) {
    return '-'
  }
  
  return String(value)
}

const handleSort = (column: TableColumn) => {
  if (!column.sortable) return
  
  if (sortField.value === column.key) {
    sortDirection.value = sortDirection.value === 'asc' ? 'desc' : 'asc'
  } else {
    sortField.value = column.key
    sortDirection.value = 'asc'
  }
  
  emit('sort', sortField.value, sortDirection.value)
}

const handleRowClick = (item: T) => {
  emit('rowClick', item)
}

const updateFilters = (newFilters: Record<string, any>) => {
  filters.value = { ...filters.value, ...newFilters }
  currentPage.value = 1 // Reset to first page
  emit('filter', filters.value)
}

// Watchers
watch(searchQuery, (newQuery) => {
  currentPage.value = 1 // Reset to first page
  emit('search', newQuery)
})

watch(filteredItems, () => {
  // Reset to first page when items change
  if (currentPage.value > totalPages.value) {
    currentPage.value = Math.max(1, totalPages.value)
  }
})
</script>
```

## 7. Testing Strategies

### 7.1 Component Testing with Vitest
```typescript
// tests/components/UserProfile.test.ts
import { describe, it, expect, vi, beforeEach } from 'vitest'
import { mount } from '@vue/test-utils'
import { createPinia, setActivePinia } from 'pinia'
import UserProfile from '@/components/UserProfile.vue'
import { useUserStore } from '@/stores/user'

// Mock the user store
vi.mock('@/stores/user')

describe('UserProfile', () => {
  let wrapper: any
  let userStore: any

  beforeEach(() => {
    setActivePinia(createPinia())
    userStore = useUserStore()
    
    // Setup store mocks
    userStore.fetchUser = vi.fn().mockResolvedValue({
      id: '1',
      name: 'John Doe',
      email: 'john@example.com'
    })
    
    wrapper = mount(UserProfile, {
      props: {
        userId: '1'
      },
      global: {
        stubs: {
          UserHeader: true,
          UserDetails: true,
          UserActions: true
        }
      }
    })
  })

  it('renders user profile correctly', () => {
    expect(wrapper.find('.user-profile').exists()).toBe(true)
  })

  it('fetches user data on mount', async () => {
    expect(userStore.fetchUser).toHaveBeenCalledWith('1')
  })

  it('handles user update correctly', async () => {
    const updatedUser = { id: '1', name: 'Jane Doe', email: 'jane@example.com' }
    userStore.updateUser = vi.fn().mockResolvedValue(updatedUser)

    await wrapper.vm.handleUpdate(updatedUser)

    expect(userStore.updateUser).toHaveBeenCalledWith(updatedUser)
    expect(wrapper.emitted('userUpdated')).toBeTruthy()
  })

  it('handles user deletion correctly', async () => {
    userStore.deleteUser = vi.fn().mockResolvedValue(undefined)
    window.confirm = vi.fn().mockReturnValue(true)

    await wrapper.vm.handleDelete()

    expect(userStore.deleteUser).toHaveBeenCalledWith('1')
    expect(wrapper.emitted('userDeleted')).toBeTruthy()
  })
})
```

### 7.2 Store Testing
```typescript
// tests/stores/user.test.ts
import { describe, it, expect, beforeEach, vi } from 'vitest'
import { setActivePinia, createPinia } from 'pinia'
import { useUserStore } from '@/stores/user'
import { userService } from '@/services/userService'

// Mock the user service
vi.mock('@/services/userService')

describe('User Store', () => {
  beforeEach(() => {
    setActivePinia(createPinia())
    vi.clearAllMocks()
  })

  it('fetches users successfully', async () => {
    const mockUsers = [
      { id: '1', name: 'John Doe', email: 'john@example.com' },
      { id: '2', name: 'Jane Doe', email: 'jane@example.com' }
    ]

    userService.getUsers = vi.fn().mockResolvedValue({ data: mockUsers })

    const store = useUserStore()
    await store.fetchUsers()

    expect(store.users).toEqual(mockUsers)
    expect(store.loading).toBe(false)
    expect(store.error).toBe(null)
  })

  it('handles fetch users error', async () => {
    const errorMessage = 'Failed to fetch users'
    userService.getUsers = vi.fn().mockRejectedValue(new Error(errorMessage))

    const store = useUserStore()
    
    try {
      await store.fetchUsers()
    } catch (error) {
      expect(store.error).toBe(errorMessage)
      expect(store.loading).toBe(false)
    }
  })

  it('creates user successfully', async () => {
    const newUser = { id: '3', name: 'Bob Smith', email: 'bob@example.com' }
    const userData = { name: 'Bob Smith', email: 'bob@example.com' }

    userService.createUser = vi.fn().mockResolvedValue(newUser)

    const store = useUserStore()
    const result = await store.createUser(userData)

    expect(result).toEqual(newUser)
    expect(store.users).toContain(newUser)
  })
})
```

## 8. Build and Deployment

### 8.1 Vite Configuration
```typescript
// vite.config.ts
import { defineConfig } from 'vite'
import vue from '@vitejs/plugin-vue'
import { resolve } from 'path'

export default defineConfig({
  plugins: [vue()],
  
  resolve: {
    alias: {
      '@': resolve(__dirname, 'src')
    }
  },
  
  build: {
    target: 'esnext',
    outDir: 'dist',
    sourcemap: true,
    rollupOptions: {
      output: {
        manualChunks: {
          vendor: ['vue', 'vue-router', 'pinia'],
          ui: ['@headlessui/vue', '@heroicons/vue']
        }
      }
    }
  },
  
  server: {
    port: 3000,
    proxy: {
      '/api': {
        target: 'http://localhost:8080',
        changeOrigin: true
      },
      '/grpc': {
        target: 'http://localhost:8081',
        changeOrigin: true
      }
    }
  },
  
  test: {
    environment: 'happy-dom',
    setupFiles: ['./tests/setup.ts']
  }
})
```

### 8.2 Dockerfile
```dockerfile
# Multi-stage build for Vue.js application
FROM node:18-alpine AS builder

WORKDIR /app

# Copy package files
COPY package*.json ./
RUN npm ci --only=production

# Copy source code
COPY . .

# Build application
RUN npm run build

# Production stage
FROM nginx:alpine

# Copy custom nginx config
COPY nginx.conf /etc/nginx/nginx.conf

# Copy built application
COPY --from=builder /app/dist /usr/share/nginx/html

# Add health check
HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \
  CMD curl -f http://localhost/ || exit 1

EXPOSE 80

CMD ["nginx", "-g", "daemon off;"]
```

### 8.3 Nginx Configuration
```nginx
# nginx.conf
events {
    worker_connections 1024;
}

http {
    include       /etc/nginx/mime.types;
    default_type  application/octet-stream;
    
    sendfile        on;
    keepalive_timeout  65;
    
    # Gzip compression
    gzip on;
    gzip_vary on;
    gzip_min_length 1024;
    gzip_types
        text/plain
        text/css
        text/xml
        text/javascript
        application/javascript
        application/xml+rss
        application/json;
    
    server {
        listen 80;
        server_name localhost;
        root /usr/share/nginx/html;
        index index.html;
        
        # API proxy
        location /api/ {
            proxy_pass http://backend:8080/;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
        }
        
        # gRPC proxy
        location /grpc/ {
            proxy_pass http://grpc-backend:8081/;
            proxy_http_version 1.1;
            proxy_set_header Upgrade $http_upgrade;
            proxy_set_header Connection 'upgrade';
            proxy_set_header Host $host;
            proxy_cache_bypass $http_upgrade;
        }
        
        # Vue.js SPA fallback
        location / {
            try_files $uri $uri/ /index.html;
        }
        
        # Static assets caching
        location ~* \.(js|css|png|jpg|jpeg|gif|ico|svg)$ {
            expires 1y;
            add_header Cache-Control "public, immutable";
        }
    }
}
