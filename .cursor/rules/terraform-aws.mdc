---
description: 
globs: 
alwaysApply: false
---
# AWS Terraform Configuration Rules

## Table of Contents
1. [File Organization](mdc:#file-organization)
2. [AWS-Specific Naming Conventions](mdc:#aws-specific-naming-conventions)
3. [AWS Security Best Practices](mdc:#aws-security-best-practices)
4. [AWS Networking Best Practices](mdc:#aws-networking-best-practices)
5. [AWS Storage Configuration](mdc:#aws-storage-configuration)
6. [AWS Monitoring and Logging](mdc:#aws-monitoring-and-logging)
7. [AWS Cost Management](mdc:#aws-cost-management)
8. [AWS Backup and Recovery](mdc:#aws-backup-and-recovery)
9. [Best Practices for AWS Resources](mdc:#best-practices-for-aws-resources)

## File Organization

### Project Structure
```
terraform-aws-project/
├── providers.tf          # AWS Provider and AWS-specific configurations
├── backend.tf           # S3 backend configuration
├── versions.tf          # AWS provider version constraints
├── variables.tf         # Input variables
├── outputs.tf          # Output definitions
├── locals.tf           # Local variables
├── terraform.tfvars    # Variable values
├── data.tf            # AWS data sources
│
# Networking
├── vpc.tf             # VPC configuration
├── subnets.tf         # Public and private subnets
├── route_tables.tf    # Route tables and routes
├── endpoints.tf       # VPC endpoints
├── transit_gateway.tf # Transit Gateway configuration
│
# Security
├── iam.tf            # IAM roles, policies, and users
├── kms.tf            # KMS keys and aliases
├── security_groups.tf # Security Groups
├── acm.tf           # ACM certificates
├── waf.tf           # WAF configurations
│
# Compute
├── ec2.tf           # EC2 instances
├── asg.tf           # Auto Scaling Groups
├── ecs.tf           # ECS clusters and services
├── eks.tf           # EKS clusters
├── lambda.tf        # Lambda functions
│
# Storage
├── s3.tf            # S3 buckets and policies
├── rds.tf           # RDS instances
├── dynamodb.tf      # DynamoDB tables
├── elasticache.tf   # ElastiCache clusters
│
# Content Delivery
├── cloudfront.tf    # CloudFront distributions
├── route53.tf       # Route53 zones and records
│
# Monitoring
├── cloudwatch.tf    # CloudWatch metrics and alarms
├── logs.tf         # CloudWatch Log groups
├── sns.tf          # SNS topics
├── eventbridge.tf  # EventBridge rules
```

## AWS-Specific Naming Conventions

### 1. Resource Naming Pattern
```hcl
locals {
  # Standard AWS resource prefix
  prefix = "${var.project}-${var.environment}-${data.aws_region.current.name}"
  
  # Common AWS tags
  common_tags = {
    Project     = var.project
    Environment = var.environment
    ManagedBy   = "terraform"
    Owner       = var.team
    CostCenter  = var.cost_center
  }
}

# Example resource names
resource "aws_s3_bucket" "logs" {
  bucket = "${local.prefix}-logs"
  # ... configuration
}

resource "aws_iam_role" "lambda" {
  name = "${local.prefix}-lambda-execution"
  # ... configuration
}
```

### 2. AWS-Specific Variable Validation

```hcl
# EC2 Instance Type Validation
variable "instance_type" {
  type        = string
  description = "EC2 instance type"
  
  validation {
    condition     = can(regex("^[t2|t3|m5|c5|r5|i3|g4]", var.instance_type))
    error_message = "Instance type must be a valid AWS instance type."
  }
}

# S3 Bucket Name Validation
variable "bucket_name" {
  type        = string
  description = "S3 bucket name"
  
  validation {
    condition     = can(regex("^[a-z0-9][a-z0-9.-]*[a-z0-9]$", var.bucket_name))
    error_message = "Bucket name must be valid S3 bucket name (lowercase alphanumeric, dots, and hyphens)."
  }
}

# KMS Key Alias Validation
variable "kms_alias" {
  type        = string
  description = "KMS key alias"
  
  validation {
    condition     = can(regex("^alias/[a-zA-Z0-9/_-]+$", var.kms_alias))
    error_message = "KMS alias must start with 'alias/' and contain only alphanumeric characters, /, _, or -"
  }
}
```

## AWS Security Best Practices

### 1. IAM Configuration
```hcl
# IAM Role with Least Privilege
resource "aws_iam_role" "service_role" {
  name = "${local.prefix}-service"
  
  assume_role_policy = jsonencode({
    Version = "2012-10-17"
    Statement = [{
      Action = "sts:AssumeRole"
      Effect = "Allow"
      Principal = {
        Service = "ec2.amazonaws.com"
      }
    }]
  })
}

# Custom IAM Policy
resource "aws_iam_policy" "service_policy" {
  name = "${local.prefix}-service-policy"
  
  policy = jsonencode({
    Version = "2012-10-17"
    Statement = [{
      Effect = "Allow"
      Action = [
        "s3:GetObject",
        "s3:PutObject"
      ]
      Resource = [
        "${aws_s3_bucket.data.arn}/*"
      ]
    }]
  })
}
```

### 2. Security Group Rules
```hcl
# Security Group with Specific Rules
resource "aws_security_group" "app" {
  name        = "${local.prefix}-app"
  description = "Application security group"
  vpc_id      = aws_vpc.main.id

  # Ingress rules
  ingress {
    from_port       = 443
    to_port         = 443
    protocol        = "tcp"
    security_groups = [aws_security_group.alb.id]
    description     = "HTTPS from ALB"
  }

  # Egress rules
  egress {
    from_port   = 0
    to_port     = 0
    protocol    = "-1"
    cidr_blocks = ["0.0.0.0/0"]
    description = "Allow all outbound traffic"
  }

  tags = merge(
    local.common_tags,
    {
      Name = "${local.prefix}-app"
    }
  )
}
```

## AWS Networking Best Practices

### 1. VPC Configuration
```hcl
# VPC with Private/Public Subnets
resource "aws_vpc" "main" {
  cidr_block           = var.vpc_cidr
  enable_dns_hostnames = true
  enable_dns_support   = true
  
  tags = merge(
    local.common_tags,
    {
      Name = "${local.prefix}-vpc"
    }
  )
}

# Public Subnet
resource "aws_subnet" "public" {
  count             = length(var.public_subnet_cidrs)
  vpc_id            = aws_vpc.main.id
  cidr_block        = var.public_subnet_cidrs[count.index]
  availability_zone = data.aws_availability_zones.available.names[count.index]
  
  map_public_ip_on_launch = true
  
  tags = merge(
    local.common_tags,
    {
      Name = "${local.prefix}-public-${count.index + 1}"
      Tier = "Public"
    }
  )
}
```

## AWS Storage Configuration

### 1. S3 Bucket Configuration
```hcl
# S3 Bucket with Best Practices
resource "aws_s3_bucket" "data" {
  bucket = "${local.prefix}-data"
  
  tags = local.common_tags
}

resource "aws_s3_bucket_versioning" "data" {
  bucket = aws_s3_bucket.data.id
  versioning_configuration {
    status = "Enabled"
  }
}

resource "aws_s3_bucket_server_side_encryption_configuration" "data" {
  bucket = aws_s3_bucket.data.id
  
  rule {
    apply_server_side_encryption_by_default {
      sse_algorithm     = "aws:kms"
      kms_master_key_id = aws_kms_key.s3.id
    }
  }
}

resource "aws_s3_bucket_public_access_block" "data" {
  bucket = aws_s3_bucket.data.id
  
  block_public_acls       = true
  block_public_policy     = true
  ignore_public_acls      = true
  restrict_public_buckets = true
}
```

## AWS Monitoring and Logging

### 1. CloudWatch Configuration
```hcl
# CloudWatch Log Group
resource "aws_cloudwatch_log_group" "app" {
  name              = "/aws/${local.prefix}/app"
  retention_in_days = 30
  
  tags = local.common_tags
}

# CloudWatch Metric Alarm
resource "aws_cloudwatch_metric_alarm" "cpu_high" {
  alarm_name          = "${local.prefix}-cpu-utilization-high"
  comparison_operator = "GreaterThanThreshold"
  evaluation_periods  = "2"
  metric_name        = "CPUUtilization"
  namespace          = "AWS/EC2"
  period             = "300"
  statistic          = "Average"
  threshold          = "80"
  
  alarm_description = "CPU utilization is too high"
  alarm_actions     = [aws_sns_topic.alerts.arn]
  
  dimensions = {
    AutoScalingGroupName = aws_autoscaling_group.app.name
  }
  
  tags = local.common_tags
}
```

## AWS Cost Management

### 1. Cost Allocation Tags
```hcl
# Enable cost allocation tags
resource "aws_ce_tags" "cost_tags" {
  tags = [
    "Project",
    "Environment",
    "CostCenter",
    "Owner"
  ]
}

# Apply consistent tagging
locals {
  required_tags = {
    Project     = var.project_name
    Environment = var.environment
    CostCenter  = var.cost_center
    Owner       = var.team_email
  }
}
```

## AWS Backup and Recovery

### 1. Backup Configuration
```hcl
# AWS Backup vault
resource "aws_backup_vault" "main" {
  name = "${local.prefix}-backup-vault"
  
  tags = local.common_tags
}

# AWS Backup plan
resource "aws_backup_plan" "main" {
  name = "${local.prefix}-backup-plan"
  
  rule {
    rule_name         = "daily_backup"
    target_vault_name = aws_backup_vault.main.name
    schedule          = "cron(0 5 ? * * *)"
    
    lifecycle {
      delete_after = 30
    }
  }
  
  tags = local.common_tags
}
```

## Best Practices for AWS Resources

1. **Resource Organization**
   - Group related AWS resources in the same file
   - Use consistent naming across AWS services
   - Follow AWS service limits and quotas

2. **Security**
   - Use KMS encryption for sensitive data
   - Implement least privilege access
   - Enable VPC flow logs
   - Use security groups effectively

3. **Networking**
   - Plan IP addressing carefully
   - Use private subnets for internal resources
   - Implement proper route tables
   - Use VPC endpoints where possible

4. **Monitoring**
   - Enable detailed monitoring for critical resources
   - Set up appropriate CloudWatch alarms
   - Configure proper log retention
   - Use AWS X-Ray for tracing

5. **Cost Management**
   - Use appropriate instance sizes
   - Implement auto-scaling
   - Clean up unused resources
   - Monitor costs regularly
